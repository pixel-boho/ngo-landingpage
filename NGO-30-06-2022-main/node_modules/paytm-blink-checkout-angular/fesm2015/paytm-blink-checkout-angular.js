import { ReplaySubject } from 'rxjs';
import { InjectionToken, Injectable, Inject, NgModule, defineInjectable, inject, Component } from '@angular/core';
import { DOCUMENT, CommonModule } from '@angular/common';

const CONSTANTS = {
    PROJECT_NAME: 'Paytm Blink Checkout JS',
    ENV: {
        PROD: 'PROD',
        STAGE: 'STAGE'
    },
    HOSTS: {
        PROD: 'https://securegw.paytm.in',
        STAGE: 'https://securegw-stage.paytm.in'
    },
    LINKS: {
        CHECKOUT_JS_URL: '/merchantpgpui/checkoutjs/merchants/'
    },
    ERRORS: {
        INIT: 'An error during initialization!',
        INVOKE: 'An error during invoking!',
        MERCHANT_ID_NOT_FOUND: 'Please provide merchant id!',
        CHECKOUT_NOT_AVAILABLE: 'Checkout JS library not found. Please make sure you have included checkout js!',
        INVALID_CHECKOUT_JS_INSTANCE: 'Invalid instance provided!'
    },
    IDS: {
        CHECKOUT_ELEMENT: 'checkout-wrapper-'
    }
};
// Prefix error with project name
Object.keys(CONSTANTS.ERRORS).forEach(errorCode => {
    CONSTANTS.ERRORS[errorCode] = `${CONSTANTS.PROJECT_NAME}: ${CONSTANTS.ERRORS[errorCode]}`;
});

const WINDOW_TOKEN = new InjectionToken('Window', {
    providedIn: 'root',
    factory: () => window
});

class CheckoutOptions {
    constructor(env, openInPopup, checkoutJsInstance) {
        this.env = env;
        this.openInPopup = openInPopup;
        this.checkoutJsInstance = checkoutJsInstance;
    }
    static from(options) {
        options = options || {};
        const env = options.env || CONSTANTS.ENV.PROD;
        const openInPopup = typeof options.openInPopup === 'boolean' ? options.openInPopup : true;
        return new CheckoutOptions(env, openInPopup, options.checkoutJsInstance);
    }
}

class CheckoutService {
    constructor(window, document) {
        this.window = window;
        this.document = document;
        this.openInPopup = true;
        this.isScriptLoaded = false;
        this.isScriptLoading = false;
        this.checkoutJsContainerId = CONSTANTS.IDS.CHECKOUT_ELEMENT + (new Date()).getTime();
        this.checkoutJsInstanceSource$ = new ReplaySubject(1);
        this.checkoutJsInstance$ = this.checkoutJsInstanceSource$.asObservable();
        this.setupCheckoutJs = () => {
            const checkoutJsInstance = this.getCheckoutJsObj();
            if (checkoutJsInstance && checkoutJsInstance.onLoad) {
                checkoutJsInstance.onLoad(() => {
                    this.isScriptLoaded = true;
                    this.isScriptLoading = false;
                    this.initializeCheckout();
                });
            }
        };
        this.initializeCheckout = () => {
            const checkoutJsInstance = this.getCheckoutJsObj();
            if (checkoutJsInstance && checkoutJsInstance.init && checkoutJsInstance.invoke) {
                checkoutJsInstance
                    .init(Object.assign({}, this.config, { root: this.openInPopup ? '' : `#${this.checkoutJsContainerId}` }))
                    .then(_ => {
                    this.checkoutJsInstanceSource$.next(checkoutJsInstance);
                })
                    .catch((error) => {
                    console.error(CONSTANTS.ERRORS.INIT, error);
                });
            }
            else {
                console.error(CONSTANTS.ERRORS.INVALID_CHECKOUT_JS_INSTANCE);
            }
        };
    }
    init(config, options) {
        options = CheckoutOptions.from(options);
        const merchantId = config && config.merchant && config.merchant.mid;
        if (merchantId) {
            const prevMerchantId = this.config && this.config.merchant && this.config.merchant.mid;
            this.config = config;
            this.openInPopup = options.openInPopup;
            if (options.checkoutJsInstance) {
                this.receivedCheckoutJsInstance = options.checkoutJsInstance;
                this.checkoutJsInstanceSource$.next(options.checkoutJsInstance);
            }
            if ((options.checkoutJsInstance || this.isScriptLoaded) && merchantId === prevMerchantId) {
                this.initializeCheckout();
                this.checkoutJsInstance$;
            }
            else if (!this.isScriptLoading || (prevMerchantId && merchantId !== prevMerchantId)) {
                this.loadCheckoutScript(merchantId, options.env);
            }
        }
        else {
            console.error(CONSTANTS.ERRORS.MERCHANT_ID_NOT_FOUND);
        }
    }
    loadCheckoutScript(merchantId, env) {
        this.isScriptLoaded = false;
        this.isScriptLoading = true;
        const scriptElement = this.document.createElement('script');
        scriptElement.async = true;
        scriptElement.src = CONSTANTS.HOSTS[env] + CONSTANTS.LINKS.CHECKOUT_JS_URL.concat(merchantId);
        scriptElement.type = 'application/javascript';
        scriptElement.onload = this.setupCheckoutJs;
        scriptElement.onError = () => {
            this.isScriptLoading = false;
        };
        this.document.body.appendChild(scriptElement);
    }
    getCheckoutJsObj() {
        const window = this.window;
        if (this.receivedCheckoutJsInstance) {
            return this.receivedCheckoutJsInstance;
        }
        if (window && window.Paytm && window.Paytm.CheckoutJS) {
            return window.Paytm.CheckoutJS;
        }
        console.warn(CONSTANTS.ERRORS.CHECKOUT_NOT_AVAILABLE);
        return null;
    }
    ngOnDestroy() {
        this.checkoutJsInstanceSource$.complete();
    }
}
CheckoutService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
CheckoutService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [WINDOW_TOKEN,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
CheckoutService.ngInjectableDef = defineInjectable({ factory: function CheckoutService_Factory() { return new CheckoutService(inject(WINDOW_TOKEN), inject(DOCUMENT)); }, token: CheckoutService, providedIn: "root" });

class CheckoutComponent {
    constructor(checkoutService) {
        this.checkoutService = checkoutService;
    }
    ngAfterViewInit() {
        this.subs = this.checkoutService
            .checkoutJsInstance$
            .subscribe(this.invoke);
    }
    invoke(checkoutJsInstance) {
        if (checkoutJsInstance && checkoutJsInstance.invoke) {
            try {
                checkoutJsInstance.invoke();
            }
            catch (error) {
                console.error(CONSTANTS.ERRORS.INVOKE, error);
            }
        }
    }
    ngOnDestroy() {
        if (this.subs) {
            this.subs.unsubscribe();
        }
    }
}
CheckoutComponent.decorators = [
    { type: Component, args: [{
                selector: 'paytm-checkout',
                template: `<div [id]="checkoutService.checkoutJsContainerId"><div>`
            }] }
];
/** @nocollapse */
CheckoutComponent.ctorParameters = () => [
    { type: CheckoutService }
];

class CheckoutModule {
}
CheckoutModule.decorators = [
    { type: NgModule, args: [{
                declarations: [CheckoutComponent],
                imports: [CommonModule],
                exports: [CheckoutComponent]
            },] }
];

/*
 * Public API Surface of angular-checkout-js
 */

/**
 * Generated bundle index. Do not edit.
 */

export { WINDOW_TOKEN as Éµb, CheckoutService, CheckoutComponent, CheckoutModule };

//# sourceMappingURL=paytm-blink-checkout-angular.js.map